import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext, filedialog
from PIL import Image, ImageTk
import cv2
import numpy as np
from pymongo import MongoClient
from datetime import datetime
import os
import threading
import pandas as pd
from bson import ObjectId

# -------------------- Database Manager --------------------
class DatabaseManager:
    def __init__(self, connection_string="mongodb://localhost:27017/"):
        self.connection_string = connection_string
        self.client = None
        self.db = None
        self.users_collection = None
        self.attendance_collection = None
        self.connected = False
        
    def connect(self):
        try:
            # Added serverSelectionTimeoutMS for faster failure on no connection
            self.client = MongoClient(self.connection_string, serverSelectionTimeoutMS=5000)
            self.client.server_info() # The ismaster command is cheap and does not require auth.
            self.db = self.client["gesture_login_db"]
            self.users_collection = self.db["users"]
            self.attendance_collection = self.db["attendance"]
            self.connected = True
            return True
        except Exception as e:
            self.connected = False
            self.error = str(e)
            return False
    
    def get_all_users(self):
        # Only return users who have completed face registration
        return list(self.users_collection.find({"face_registered": True}))
    
    def get_user(self, emp_id):
        return self.users_collection.find_one({"emp_id": emp_id})
    
    def create_user(self, emp_id, name):
        # Use update_one with upsert=True to either create or update a user
        return self.users_collection.update_one(
            {"emp_id": emp_id},
            {"$set": {
                "name": name,
                "face_registered": True,
                "registered_on": datetime.now()
            }},
            upsert=True
        )
    
    def delete_user(self, emp_id):
        # Delete user record
        result = self.users_collection.delete_one({"emp_id": emp_id})
        # Optionally, delete attendance records as well
        self.attendance_collection.delete_many({"emp_id": emp_id})
        return result.deleted_count > 0
    
    def log_attendance(self, emp_id, name, action, method="face"):
        log_data = {
            "emp_id": emp_id,
            "name": name,
            "action": action, # "LOGIN" or "LOGOUT"
            "timestamp": datetime.now(),
            "method": method # "face", "gesture", "manual", or "auto"
        }
        return self.attendance_collection.insert_one(log_data)
    
    def get_attendance_records(self, emp_id=None, limit=100):
        query = {"emp_id": emp_id} if emp_id else {}
        return list(self.attendance_collection.find(query).sort("timestamp", -1).limit(limit))
    
    def get_logged_in_users(self):
        """
        Determines currently logged-in users by comparing the latest LOGIN to the latest LOGOUT.
        """
        # 1. Find the latest LOGIN timestamp for each user
        recent_logins = list(self.attendance_collection.aggregate([
            {"$match": {"action": "LOGIN"}},
            {"$sort": {"timestamp": -1}},
            {"$group": {"_id": "$emp_id", "latest_login": {"$first": "$timestamp"}}}
        ]))
        
        logged_in_users = set()
        for login in recent_logins:
            emp_id = login["_id"]
            latest_logout = self.attendance_collection.find_one(
                {"emp_id": emp_id, "action": "LOGOUT", "timestamp": {"$gt": login["latest_login"]}},
                sort=[("timestamp", -1)]
            )
            # If there's no logout *after* the latest login, the user is still logged in
            if not latest_logout:
                logged_in_users.add(emp_id)
                
        return logged_in_users
    
    def generate_employee_id(self):
        last_user = self.users_collection.find_one({}, sort=[("emp_id", -1)])
        if last_user and "emp_id" in last_user:
            last_id = last_user["emp_id"]
            if last_id.startswith("ALLY"):
                try:
                    # Extract number, increment it, and format
                    num = int(last_id[4:]) + 1
                    return f"ALLY{num:04d}"
                except ValueError:
                    # Fallback if the number part is not a valid integer
                    pass
        return "ALLY0001"
    
    def close(self):
        if self.client:
            self.client.close()

# -------------------- Face Recognition System --------------------
class SimpleFaceRecognizer:
    def __init__(self, threshold=60): # Lowered threshold to 60 for better demo
        self.threshold = threshold
        self.known_faces = {}
    
    def add_face(self, face_id, face_image):
        """Adds a face image to the known faces for a given ID."""
        if face_id not in self.known_faces:
            self.known_faces[face_id] = []
        # face_image is expected to be a grayscale, resized 200x200 numpy array
        self.known_faces[face_id].append(face_image)
    
    def recognize_face(self, test_image):
        """
        Recognizes a face using a simple Mean Squared Error (MSE) comparison.
        Lower MSE means higher similarity.
        """
        best_match = None
        best_score = float('inf')
        
        # Ensure the test image is ready (grayscale, 200x200)
        gray_test = cv2.cvtColor(test_image, cv2.COLOR_BGR2GRAY) if len(test_image.shape) == 3 else test_image
        try:
            gray_test = cv2.resize(gray_test, (200, 200))
        except cv2.error:
            return None, 0 # Handle case where resize fails (e.g., empty image)
        
        # Compare test image against all known training images
        for face_id, training_images in self.known_faces.items():
            for train_img in training_images:
                # Calculate Mean Squared Error (MSE)
                # Resizing train_img is redundant if it was saved as 200x200
                score = np.mean((gray_test.astype(float) - train_img.astype(float)) ** 2)
                
                if score < best_score:
                    best_score = score
                    best_match = face_id
        
        # Simple heuristic to convert MSE (score) to confidence percentage
        # A score of 0 is 100% confidence. A higher score means lower confidence.
        # This formula is highly simplified. 1000000 is an arbitrary high score.
        confidence = max(0, 100 - (best_score / 1000)) 
        
        if confidence > self.threshold:
            return best_match, confidence
        else:
            return None, confidence

class FaceRecognitionSystem:
    def __init__(self, data_dir="data/faces"):
        self.data_dir = data_dir
        self.models_dir = "models" # Not strictly used for SimpleFaceRecognizer but good practice
        os.makedirs(self.data_dir, exist_ok=True)
        os.makedirs(self.models_dir, exist_ok=True)
        
        # Load pre-trained Haar Cascade for face detection
        self.face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
        self.face_recognizer = SimpleFaceRecognizer(threshold=60)
        
        self.known_faces = {}
        self.is_capturing = False
        self.stop_capture = False
        self.live_camera_active = False
        self.camera_thread = None

    def load_known_faces(self, users):
        """Load registered face images from the file system into the recognizer."""
        self.known_faces = {}
        # Clear existing faces before loading new ones
        self.face_recognizer.known_faces = {} 
        
        for user in users:
            emp_id = user["emp_id"]
            self.known_faces[emp_id] = {
                "name": user.get("name", emp_id),
                "_id": user.get("_id")
            }
            
            # The saved image for each user is the one used for "training"
            img_path = os.path.join(self.data_dir, f"{emp_id}.jpg")
            if os.path.exists(img_path):
                # Read as grayscale and expect it to be 200x200
                img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
                if img is not None and img.shape == (200, 200):
                    self.face_recognizer.add_face(emp_id, img)
                elif img is not None:
                    # If it's not the right size, resize and add
                    img_resized = cv2.resize(img, (200, 200))
                    self.face_recognizer.add_face(emp_id, img_resized)

    def register_face(self, emp_id, name, callback):
        """Captures a face image for a new user and saves it."""
        self.stop_capture = False
        captured_faces = []
        samples_needed = 100 # In this simple implementation, only the first image is saved and used
        
        cam = cv2.VideoCapture(0)
        if not cam.isOpened():
            callback(False, "Cannot access camera")
            return

        while len(captured_faces) < samples_needed and not self.stop_capture:
            ret, frame = cam.read()
            if not ret:
                break

            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            faces = self.face_cascade.detectMultiScale(gray, 1.3, 5, minSize=(100, 100))
            
            frame_display = frame.copy()
            
            for (x, y, w, h) in faces:
                cv2.rectangle(frame_display, (x, y), (x+w, y+h), (0, 255, 0), 2)
                
                if len(faces) == 1:
                    cv2.putText(frame_display, f"Capturing: {len(captured_faces)}/{samples_needed}", 
                              (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
            
            cv2.imshow("Registration - Press Q to cancel", frame_display)
            key = cv2.waitKey(1) & 0xFF
            
            if key == ord('q'):
                self.stop_capture = True
                break
            
            # Capture only the first face found in the frame
            if len(faces) == 1:
                x, y, w, h = faces[0]
                face_roi = gray[y:y+h, x:x+w]
                
                # Check for a valid region of interest
                if face_roi.size > 0:
                    face_roi_resized = cv2.resize(face_roi, (200, 200))
                    captured_faces.append(face_roi_resized)
                    
                    if len(captured_faces) == 1:
                        # Save the first sample and add it to the recognizer
                        image_path = os.path.join(self.data_dir, f"{emp_id}.jpg")
                        cv2.imwrite(image_path, face_roi_resized)
                        self.face_recognizer.add_face(emp_id, face_roi_resized)
                    
                    callback(False, f"Captured {len(captured_faces)}/{samples_needed}")

        cam.release()
        cv2.destroyAllWindows()

        if self.stop_capture or len(captured_faces) < 1: # Check if at least one image was captured
            callback(False, "Registration cancelled or failed to capture face")
            return

        callback(True, f"Face registered for {name} ({emp_id}). Please click 'Refresh List'")

    def start_live_recognition(self, callback):
        """Starts a background thread for continuous face recognition and logging."""
        if len(self.known_faces) == 0:
            callback(None, "No registered users found")
            return False

        if self.live_camera_active:
            # Already running, do nothing
            return True

        self.live_camera_active = True
        # Use a non-blocking thread for the CV loop
        self.camera_thread = threading.Thread(target=self._live_recognition_loop, args=(callback,))
        self.camera_thread.daemon = True
        self.camera_thread.start()
        return True

    def stop_live_recognition(self):
        """Stops the live recognition thread gracefully."""
        self.live_camera_active = False
        if self.camera_thread and self.camera_thread.is_alive():
            # Wait a short time for the thread to exit
            self.camera_thread.join(timeout=2)
            
    def _live_recognition_loop(self, callback):
        """The main loop for continuous recognition in a separate thread."""
        cam = cv2.VideoCapture(0)
        if not cam.isOpened():
            callback(None, "Cannot access camera in thread")
            return

        # Cooldown timer to prevent rapid-fire log entries
        last_recognition_time = datetime.now()
        recognition_cooldown = 5 # seconds
        
        try:
            while self.live_camera_active:
                ret, frame = cam.read()
                if not ret:
                    break
                
                frame = cv2.flip(frame, 1) # Mirror the image
                gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
                faces = self.face_cascade.detectMultiScale(gray, 1.3, 5)
                
                current_time = datetime.now()
                time_since_last_recognition = (current_time - last_recognition_time).total_seconds()
                
                # We only process one face in the live recognition loop for simplicity
                if len(faces) > 0:
                    x, y, w, h = faces[0]
                    face_roi = gray[y:y+h, x:x+w]
                    emp_id, confidence = self.face_recognizer.recognize_face(face_roi)
                    
                    text = "Unknown"
                    color = (0, 0, 255) # Red for Unknown
                    
                    if emp_id:
                        name = self.known_faces[emp_id]["name"]
                        text = f"{name} ({int(confidence)}%)"
                        
                        if time_since_last_recognition >= recognition_cooldown:
                            # Log a LOGIN action automatically
                            threading.Thread(target=callback, args=(emp_id, f"Auto Face Login: {name}")).start()
                            last_recognition_time = current_time
                            color = (0, 255, 0) # Green for Recognized and Logged
                        else:
                            color = (255, 255, 0) # Yellow for Recognized (on cooldown)
                            
                    cv2.rectangle(frame, (x, y), (x+w, y+h), color, 2)
                    cv2.putText(frame, text, (x, y-10), 
                              cv2.FONT_HERSHEY_SIMPLEX, 0.7, color, 2)
                
                # The Tkinter app's update_frame handles showing the camera feed
                # and cv2.imshow is usually blocked by the main thread in a GUI,
                # but we'll leave it here as a fallback/debug view.
                # cv2.imshow("Live Recognition Thread", frame) 
                
                if cv2.waitKey(1) & 0xFF == ord('q'):
                    break

        except Exception as e:
            # We must use threading.Thread(target=...) to safely call back to the main thread's UI
            threading.Thread(target=callback, args=(None, f"Error in live recognition: {e}")).start()
        finally:
            cam.release()
            cv2.destroyAllWindows()
            self.live_camera_active = False
            # Ensure the main thread knows the loop has stopped
            threading.Thread(target=callback, args=(None, "Live recognition stopped.")).start()

    def recognize_face(self, callback):
        """One-shot face recognition for the login button."""
        if len(self.known_faces) == 0:
            callback(None, "No registered users found")
            return

        cam = cv2.VideoCapture(0)
        if not cam.isOpened():
            callback(None, "Cannot access camera")
            return

        recognition_frames = {}
        required_frames = 5 # Require 5 consistent recognitions for a definitive login
        self.stop_capture = False

        try:
            while not self.stop_capture:
                ret, frame = cam.read()
                if not ret:
                    break

                gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
                faces = self.face_cascade.detectMultiScale(gray, 1.3, 5, minSize=(100, 100))
                
                frame_display = frame.copy()
                
                if len(faces) > 0:
                    x, y, w, h = faces[0]
                    face_roi = gray[y:y+h, x:x+w]
                    
                    if face_roi.size > 0:
                        emp_id, confidence = self.face_recognizer.recognize_face(face_roi)
                        
                        if emp_id:
                            name = self.known_faces[emp_id]["name"]
                            
                            cv2.rectangle(frame_display, (x, y), (x+w, y+h), (0, 255, 0), 2)
                            cv2.putText(frame_display, f"{name}", (x, y-30), 
                                      cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
                            cv2.putText(frame_display, f"Conf: {int(confidence)}%", (x, y-10), 
                                      cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)
                            
                            recognition_frames[emp_id] = recognition_frames.get(emp_id, 0) + 1
                            
                            if recognition_frames[emp_id] >= required_frames:
                                cam.release()
                                cv2.destroyAllWindows()
                                callback(emp_id, f"Login successful: {name}")
                                return
                        else:
                            cv2.rectangle(frame_display, (x, y), (x+w, y+h), (0, 0, 255), 2)
                            cv2.putText(frame_display, "Unknown", (x, y-10), 
                                      cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
                            recognition_frames.clear() # Reset count if an unknown face appears

                cv2.imshow("Face Recognition - Press Q to cancel", frame_display)
                if cv2.waitKey(1) & 0xFF == ord('q'):
                    self.stop_capture = True
                    break

        except Exception as e:
            callback(None, f"Error: {e}")
        finally:
            cam.release()
            cv2.destroyAllWindows()
        
        callback(None, "No registered face recognized")

# -------------------- Gesture Detector --------------------
class GestureDetector:
    def __init__(self):
        self.stop_capture = False

    def detect_wave_gesture(self, callback):
        """Detects a 'wave' or significant hand motion using background subtraction."""
        cam = cv2.VideoCapture(0)
        if not cam.isOpened():
            callback(False, "Cannot access camera")
            return

        self.stop_capture = False
        motion_count = 0
        motion_threshold = 15 # Number of frames with significant motion
        # Background subtractor to isolate moving objects (like a hand)
        fgbg = cv2.createBackgroundSubtractorMOG2(history=500, varThreshold=16, detectShadows=False)
        
        try:
            while not self.stop_capture:
                ret, frame = cam.read()
                if not ret:
                    break

                frame = cv2.flip(frame, 1) # Mirror
                
                # Apply background subtraction
                fgmask = fgbg.apply(frame)
                
                # Further processing on the mask (optional, but helps clean up)
                kernel = np.ones((5,5), np.uint8)
                fgmask = cv2.erode(fgmask, kernel, iterations=1)
                fgmask = cv2.dilate(fgmask, kernel, iterations=1)
                
                motion_pixels = cv2.countNonZero(fgmask)
                
                # Adjust motion detection based on a pixel count threshold
                if motion_pixels > 5000: # Threshold for a large moving object
                    motion_count += 1
                    cv2.putText(frame, f"Motion detected: {motion_count}/{motion_threshold}", 
                              (50, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
                else:
                    # Decay motion count to handle momentary stops
                    motion_count = max(0, motion_count - 0.5) 
                
                cv2.putText(frame, "Wave your hand to login", (50, 450), 
                          cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
                
                # Display the motion mask for debug/visualization (optional)
                # cv2.imshow("Motion Mask", fgmask)
                cv2.imshow("Wave Gesture Login - Press Q to cancel", frame)
                
                if motion_count >= motion_threshold:
                    cam.release()
                    cv2.destroyAllWindows()
                    # Success: Gesture detected
                    callback(True, "Wave gesture detected! Starting face recognition...")
                    return
                
                if cv2.waitKey(1) & 0xFF == ord('q'):
                    self.stop_capture = True
                    break

        except Exception as e:
            callback(False, f"Error: {e}")
        finally:
            cam.release()
            cv2.destroyAllWindows()
        
        callback(False, "Wave gesture not detected or cancelled")

    def detect_fist_gesture(self, callback):
        """Detects a 'fist' or hand closure using convexity and area analysis."""
        cam = cv2.VideoCapture(0)
        if not cam.isOpened():
            callback(False, "Cannot access camera")
            return

        self.stop_capture = False
        fist_frames = 0
        fist_threshold = 20 # Number of frames a fist must be held
        
        # Skin color detection range (adjusting for better performance)
        lower_skin = np.array([0, 40, 50], dtype=np.uint8)
        upper_skin = np.array([20, 255, 255], dtype=np.uint8)
        
        try:
            while not self.stop_capture:
                ret, frame = cam.read()
                if not ret:
                    break

                frame = cv2.flip(frame, 1)
                hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
                
                # Threshold the HSV image to get only skin colors
                mask = cv2.inRange(hsv, lower_skin, upper_skin)
                
                # Morphological transformations to clean up the mask
                kernel = np.ones((5,5), np.uint8)
                mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
                mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
                
                # Find the largest contour (expected to be the hand)
                contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
                
                if contours:
                    largest_contour = max(contours, key=cv2.contourArea)
                    area = cv2.contourArea(largest_contour)
                    
                    if area > 10000: # Ensure it's a large enough object (a hand, not noise)
                        hull = cv2.convexHull(largest_contour)
                        hull_area = cv2.contourArea(hull)
                        
                        # Fist detection heuristic: a closed fist is very convex (convexity ratio close to 1)
                        if hull_area > 0:
                            convexity_ratio = area / hull_area
                            
                            # A simple fist is highly convex (little concavity)
                            if 0.9 < convexity_ratio <= 1.0:
                                fist_frames += 1
                                color = (0, 0, 255)
                                cv2.drawContours(frame, [hull], 0, color, 2)
                                cv2.putText(frame, f"Fist/Closed Hand: {fist_frames}/{fist_threshold}", 
                                          (50, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, color, 2)
                            else:
                                fist_frames = max(0, fist_frames - 1)
                        else:
                             fist_frames = max(0, fist_frames - 1)
                    else:
                        fist_frames = max(0, fist_frames - 1)
                else:
                    fist_frames = max(0, fist_frames - 1)
                
                cv2.imshow("Fist Gesture Logout - Press Q to cancel", frame)
                
                if fist_frames >= fist_threshold:
                    cam.release()
                    cv2.destroyAllWindows()
                    # Success: Gesture detected
                    callback(True, "Fist gesture detected! Logging out...")
                    return
                
                if cv2.waitKey(1) & 0xFF == ord('q'):
                    self.stop_capture = True
                    break

        except Exception as e:
            callback(False, f"Error: {e}")
        finally:
            cam.release()
            cv2.destroyAllWindows()
        
        callback(False, "Fist gesture not detected or cancelled")

# -------------------- Main Application --------------------
class HandGestureLoginApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Employee Hand Gesture Login System")
        self.root.geometry("1400x800")
        self.root.configure(bg="#2c3e50")
        
        # Initialize systems
        self.db_manager = DatabaseManager()
        if not self.db_manager.connect():
            messagebox.showerror("Database Error", f"MongoDB connection failed: {self.db_manager.error}")
            
        self.face_system = FaceRecognitionSystem()
        users = self.db_manager.get_all_users()
        self.face_system.load_known_faces(users)
        
        self.gesture_detector = GestureDetector()
        
        self.current_user = None # Holds emp_id of the currently logged-in user
        self.current_user_name = None
        self.log_visible = True
        self.live_camera_running = False
        self.camera_is_on = False # Tracks if the cv2.VideoCapture object is active for update_frame
        
        self.setup_ui()
        self.update_status()
        self.refresh_user_list()
        self.start_live_camera_feed()

    def setup_ui(self):
        # Header
        header = tk.Frame(self.root, bg="#34495e", height=80)
        header.pack(fill=tk.X)
        
        title = tk.Label(header, text="üîê Employee Hand Gesture Login System", 
                        font=("Arial", 24, "bold"), bg="#34495e", fg="white")
        title.pack(pady=20)

        # Status Bar
        self.status_frame = tk.Frame(self.root, bg="#1abc9c", height=50)
        self.status_frame.pack(fill=tk.X)
        
        self.status_label = tk.Label(self.status_frame, text="Status: Initializing", 
                                     font=("Arial", 12), bg="#1abc9c", fg="white")
        self.status_label.pack(side=tk.LEFT, padx=20, pady=10)
        
        self.user_label = tk.Label(self.status_frame, text="Not logged in", 
                                   font=("Arial", 12, "bold"), bg="#1abc9c", fg="white")
        self.user_label.pack(side=tk.RIGHT, padx=20, pady=10)

        # Control Bar
        control_frame = tk.Frame(self.root, bg="#2c3e50", height=40)
        control_frame.pack(fill=tk.X, padx=20, pady=5)
        
        # Activity Log OptionMenu
        self.log_option_var = tk.StringVar(value="Show Log")
        log_options = ["Show Log", "Hide Log"]
        self.log_option_menu = tk.OptionMenu(control_frame, self.log_option_var, *log_options, command=self.handle_log_option)
        self.log_option_menu.config(font=("Arial", 10), bg="#3498db", fg="white", cursor="hand2", width=10)
        self.log_option_menu.pack(side=tk.LEFT, padx=5, pady=5)
        
        # Live Camera Control
        self.live_camera_btn = tk.Button(control_frame, text="üìπ Stop Live Recognition", 
                                       command=self.toggle_live_camera,
                                       font=("Arial", 10), bg="#e74c3c", fg="white",
                                       cursor="hand2", relief=tk.FLAT, padx=15, pady=5)
        self.live_camera_btn.pack(side=tk.LEFT, padx=5)

        # Main Container
        self.main_container = tk.Frame(self.root, bg="#2c3e50")
        self.main_container.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        # Left Panel - User List
        self.left_panel = tk.Frame(self.main_container, bg="#34495e", width=300)
        self.left_panel.pack(side=tk.LEFT, fill=tk.BOTH, padx=(0, 10))
        
        tk.Label(self.left_panel, text="üë• Registered Users", font=("Arial", 16, "bold"), 
                bg="#34495e", fg="white").pack(pady=15)
        
        user_list_frame = tk.Frame(self.left_panel, bg="#2c3e50")
        user_list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Treeview for user list
        self.user_tree = ttk.Treeview(user_list_frame, columns=("Name", "ID", "Status"), show="headings", height=15)
        self.user_tree.pack(fill=tk.BOTH, expand=True)
        
        self.user_tree.heading("Name", text="Name")
        self.user_tree.heading("ID", text="ID")
        self.user_tree.heading("Status", text="Status")
        self.user_tree.column("Name", width=120)
        self.user_tree.column("ID", width=80)
        self.user_tree.column("Status", width=80)
        
        # Bind double-click event to delete user
        self.user_tree.bind('<Double-1>', self.delete_user_prompt)
        
        self.manual_logout_btn = tk.Button(self.left_panel, text="üñêÔ∏è Manual Logout Selected", 
                                         command=self.manual_logout_selected,
                                         font=("Arial", 11), bg="#e74c3c", fg="white",
                                         cursor="hand2", relief=tk.FLAT, padx=20, pady=10,
                                         state=tk.DISABLED)
        self.manual_logout_btn.pack(pady=10, padx=10, fill=tk.X)
        
        tk.Button(self.left_panel, text="üîÑ Refresh List & Faces", 
                 command=self.refresh_user_list,
                 font=("Arial", 11), bg="#3498db", fg="white",
                 cursor="hand2", relief=tk.FLAT, padx=20, pady=10).pack(pady=(0,10), padx=10, fill=tk.X)

        # Center Panel - Live Camera
        self.center_panel = tk.Frame(self.main_container, bg="#ecf0f1")
        self.center_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 10))
        
        # Camera Feed Label
        self.camera_label = tk.Label(self.center_panel, bg="#2c3e50")
        self.camera_label.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)
        
        self.camera_status_frame = tk.Frame(self.center_panel, bg="#ecf0f1")
        self.camera_status_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.camera_status_label = tk.Label(self.camera_status_frame, 
                                          text="üìπ Live Camera: ACTIVE - Auto detecting faces",
                                          font=("Arial", 11, "bold"), 
                                          bg="#27ae60", fg="white", padx=10, pady=5)
        self.camera_status_label.pack(fill=tk.X)

        # Right Panel - Activity Log
        self.right_panel = tk.Frame(self.main_container, bg="#bdc3c7", width=400)
        self.right_panel.pack(side=tk.RIGHT, fill=tk.BOTH)
        
        self.create_log_widgets()

        # Actions Panel
        self.actions_panel = tk.Frame(self.center_panel, bg="#ecf0f1")
        self.actions_panel.pack(fill=tk.X, padx=10, pady=10)
        
        self.create_actions_widgets()
        
        # Protocol when the app is closed
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)

    # --- UI and Helper Methods ---
    
    def on_closing(self):
        """Handle cleanup when the application is closed."""
        self.stop_live_camera()
        if hasattr(self, 'cap') and self.cap.isOpened():
            self.cap.release()
        self.db_manager.close()
        cv2.destroyAllWindows()
        self.root.destroy()
        
    def handle_log_option(self, selection):
        """Show or hide activity log based on dropdown"""
        if selection == "Show Log":
            self.right_panel.pack(side=tk.RIGHT, fill=tk.BOTH)
            self.center_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 10))
            self.log_visible = True
        else:  # Hide Log
            self.right_panel.pack_forget()
            # Repack the center panel to take up the remaining space
            self.center_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 10))
            self.log_visible = False

    def create_log_widgets(self):
        tk.Label(self.right_panel, text="üìã Activity Log", font=("Arial", 16, "bold"), 
                bg="#34495e", fg="white").pack(pady=15, fill=tk.X)
        
        self.log_text = scrolledtext.ScrolledText(self.right_panel, font=("Courier", 9), 
                                                  bg="#2c3e50", fg="#ecf0f1",
                                                  insertbackground="white",
                                                  relief=tk.FLAT, padx=10, pady=10,
                                                  state=tk.DISABLED)
        self.log_text.pack(fill=tk.BOTH, expand=True, padx=15, pady=(0,15))
        
        tk.Button(self.right_panel, text="üóëÔ∏è Clear Log", 
                 command=self.clear_log,
                 font=("Arial", 10), bg="#e67e22", fg="white",
                 cursor="hand2", relief=tk.FLAT, padx=15, pady=8).pack(pady=(0,15))

    def create_actions_widgets(self):
        # Registration Section
        reg_frame = tk.LabelFrame(self.actions_panel, text="Register New User", 
                                 font=("Arial", 12, "bold"), bg="#ecf0f1")
        reg_frame.pack(fill=tk.X, pady=5)
        
        id_frame = tk.Frame(reg_frame, bg="#ecf0f1")
        id_frame.pack(fill=tk.X, padx=10, pady=(10,0))
        
        tk.Label(id_frame, text="Employee ID:", bg="#ecf0f1").pack(side=tk.LEFT)
        self.emp_id_entry = tk.Entry(id_frame, font=("Arial", 11), width=15)
        self.emp_id_entry.pack(side=tk.LEFT, padx=5)
        
        self.auto_id_btn = tk.Button(id_frame, text="üÜî Auto Generate", 
                                    command=self.auto_generate_id,
                                    font=("Arial", 9), bg="#f39c12", fg="white",
                                    cursor="hand2", relief=tk.FLAT)
        self.auto_id_btn.pack(side=tk.LEFT, padx=5)
        
        tk.Label(reg_frame, text="Name:", bg="#ecf0f1").pack(anchor=tk.W, padx=10)
        self.name_entry = tk.Entry(reg_frame, font=("Arial", 11), width=30)
        self.name_entry.pack(padx=10, pady=5)
        
        self.register_btn = tk.Button(reg_frame, text="üì∏ Register Face", 
                                      command=self.register_user,
                                      font=("Arial", 11, "bold"), bg="#27ae60", fg="white",
                                      cursor="hand2", relief=tk.FLAT, padx=20, pady=10)
        self.register_btn.pack(pady=10)

        # Quick Actions
        actions_frame = tk.Frame(self.actions_panel, bg="#ecf0f1")
        actions_frame.pack(fill=tk.X, pady=5)
        
        # Left side - Gestures
        gesture_frame = tk.LabelFrame(actions_frame, text="Quick Actions", 
                                    font=("Arial", 12, "bold"), bg="#ecf0f1")
        gesture_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))
        
        tk.Button(gesture_frame, text="üëã Wave to Login", 
                 command=self.wave_login,
                 font=("Arial", 10), bg="#3498db", fg="white",
                 cursor="hand2", relief=tk.FLAT, padx=15, pady=8).pack(pady=5, padx=10, fill=tk.X)
        
        self.fist_logout_btn = tk.Button(gesture_frame, text="‚úä Fist to Logout", 
                                       command=self.fist_logout,
                                       font=("Arial", 10), bg="#e74c3c", fg="white",
                                       cursor="hand2", relief=tk.FLAT, padx=15, pady=8,
                                       state=tk.DISABLED)
        self.fist_logout_btn.pack(pady=5, padx=10, fill=tk.X)
        
        # Right side - Records
        records_frame = tk.LabelFrame(actions_frame, text="Records", 
                                    font=("Arial", 12, "bold"), bg="#ecf0f1")
        records_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(5, 0))
        
        tk.Button(records_frame, text="üìã My Attendance", 
                 command=self.view_my_attendance,
                 font=("Arial", 10), bg="#9b59b6", fg="white",
                 cursor="hand2", relief=tk.FLAT, padx=15, pady=8).pack(pady=5, padx=10, fill=tk.X)
        
        tk.Button(records_frame, text="üìä All Records", 
                 command=self.view_all_attendance,
                 font=("Arial", 10), bg="#9b59b6", fg="white",
                 cursor="hand2", relief=tk.FLAT, padx=15, pady=8).pack(pady=5, padx=10, fill=tk.X)
        
        tk.Button(records_frame, text="üìà Export Excel", 
                 command=self.export_to_excel,
                 font=("Arial", 10), bg="#16a085", fg="white",
                 cursor="hand2", relief=tk.FLAT, padx=15, pady=8).pack(pady=5, padx=10, fill=tk.X)
        
    def start_live_camera_feed(self):
        """Start the live camera feed display loop."""
        if not self.camera_is_on:
            self.cap = cv2.VideoCapture(0)
            if not self.cap.isOpened():
                self.log_message("ERROR: Failed to open camera.", "red")
                self.camera_is_on = False
                return
            self.camera_is_on = True
            
        self.update_frame()
        # Start the *recognition* thread after the feed starts
        self.start_live_camera()

    def update_frame(self):
        """Update the camera feed frame using the Tkinter after method."""
        if self.camera_is_on and hasattr(self, 'cap') and self.cap.isOpened():
            ret, frame = self.cap.read()
            if ret:
                # Basic frame processing for display
                frame = cv2.flip(frame, 1) # Mirror for natural feel
                frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                frame = cv2.resize(frame, (640, 480))
                
                # Overlay current status
                status_text = "LIVE RECOGNITION" if self.live_camera_running else "IDLE"
                color = (0, 255, 0) if self.live_camera_running else (255, 255, 0)
                
                cv2.putText(frame, status_text, (10, 470), 
                          cv2.FONT_HERSHEY_SIMPLEX, 0.7, color, 2)
                
                img = Image.fromarray(frame)
                imgtk = ImageTk.PhotoImage(image=img)
                self.camera_label.imgtk = imgtk
                self.camera_label.configure(image=imgtk)
            else:
                self.camera_is_on = False # Camera disconnected
                self.log_message("WARNING: Camera disconnected.", "orange")
                
        self.root.after(50, self.update_frame) # Loop every 50ms (20 FPS)

    def log_message(self, message, color="white"):
        """Writes a time-stamped message to the activity log."""
        timestamp = datetime.now().strftime("[%H:%M:%S] ")
        self.log_text.config(state=tk.NORMAL)
        self.log_text.insert(tk.END, timestamp + message + "\n", color)
        
        # Configure the tag for the color
        self.log_text.tag_config(color, foreground=color)
        
        self.log_text.see(tk.END)
        self.log_text.config(state=tk.DISABLED)

    def clear_log(self):
        """Clears the activity log."""
        self.log_text.config(state=tk.NORMAL)
        self.log_text.delete('1.0', tk.END)
        self.log_text.config(state=tk.DISABLED)
        self.log_message("Activity log cleared.", "grey")

    def update_status(self, message="Ready"):
        """Updates the main status bar and UI elements."""
        self.status_label.config(text=f"Status: {message}")
        
        if self.current_user:
            self.user_label.config(text=f"Logged In: {self.current_user_name} ({self.current_user})", bg="#2ecc71")
            self.fist_logout_btn.config(state=tk.NORMAL)
        else:
            self.user_label.config(text="Not logged in", bg="#e74c3c")
            self.fist_logout_btn.config(state=tk.DISABLED)
        
        # Enable manual logout button if a user is selected in the treeview
        try:
            selected_item = self.user_tree.selection()[0]
            selected_id = self.user_tree.item(selected_item, 'values')[1]
            if self.user_tree.item(selected_item, 'values')[2] == "IN":
                self.manual_logout_btn.config(state=tk.NORMAL)
            else:
                self.manual_logout_btn.config(state=tk.DISABLED)
        except IndexError:
            self.manual_logout_btn.config(state=tk.DISABLED)
            
        self.root.after(100, self.refresh_user_list) # Keep the list updated

    def refresh_user_list(self, user_to_select=None):
        """Refreshes the Treeview with all registered users and their login status."""
        for i in self.user_tree.get_children():
            self.user_tree.delete(i)
            
        try:
            all_users = self.db_manager.get_all_users()
            logged_in_ids = self.db_manager.get_logged_in_users()
            
            for user in all_users:
                emp_id = user['emp_id']
                name = user['name']
                status = "IN" if emp_id in logged_in_ids else "OUT"
                
                tag = "in_tag" if status == "IN" else "out_tag"
                
                self.user_tree.insert('', tk.END, values=(name, emp_id, status), tags=(tag,))

            self.user_tree.tag_configure('in_tag', background='#2ecc71', foreground='white')
            self.user_tree.tag_configure('out_tag', background='#e74c3c', foreground='white')
            
            # Re-load faces into the recognition system in case of new registrations
            self.face_system.load_known_faces(all_users)
            
            # Select the newly registered user if provided
            if user_to_select:
                for item in self.user_tree.get_children():
                    if self.user_tree.item(item, 'values')[1] == user_to_select:
                        self.user_tree.selection_set(item)
                        self.user_tree.focus(item)
                        break

            self.update_status(f"Loaded {len(all_users)} users.")

        except Exception as e:
            self.log_message(f"ERROR refreshing user list: {e}", "red")

    def delete_user_prompt(self, event):
        """Prompt to delete a user upon double-click in the Treeview."""
        try:
            selected_item = self.user_tree.selection()[0]
            user_data = self.user_tree.item(selected_item, 'values')
            emp_id, name = user_data[1], user_data[0]
            
            if messagebox.askyesno("Confirm Deletion", 
                                   f"Are you sure you want to DELETE user: {name} ({emp_id})?\n\nThis is permanent."):
                self.delete_user(emp_id)
        except IndexError:
            pass # No item selected

    def delete_user(self, emp_id):
        """Deletes a user from the database and file system."""
        try:
            # 1. Delete DB record
            if self.db_manager.delete_user(emp_id):
                # 2. Delete face image file
                image_path = os.path.join(self.face_system.data_dir, f"{emp_id}.jpg")
                if os.path.exists(image_path):
                    os.remove(image_path)
                    
                self.log_message(f"User {emp_id} deleted successfully.", "yellow")
                self.refresh_user_list()
            else:
                self.log_message(f"ERROR: Could not find user {emp_id} to delete.", "red")
        except Exception as e:
            self.log_message(f"ERROR deleting user {emp_id}: {e}", "red")

    # --- Live Recognition Methods ---
    
    def start_live_camera(self):
        """Starts the background face recognition thread."""
        if self.live_camera_running:
            return

        def recognition_callback(emp_id, message):
            """Callback function to handle results from the recognition thread."""
            self.log_message(message, "blue")
            
            # Check for auto-login event only if emp_id is returned
            if emp_id and "Auto Face Login" in message:
                self.handle_login(emp_id, "auto")

            # Update UI elements in the main thread (essential for thread safety)
            self.root.after(10, self.update_status, message)
            self.root.after(10, self.refresh_user_list)
            
            # If the thread stopped (e.g., due to an error or 'q' press), update button state
            if "stopped" in message.lower():
                self.root.after(10, self.toggle_live_camera)


        success = self.face_system.start_live_recognition(recognition_callback)
        if success:
            self.live_camera_running = True
            self.live_camera_btn.config(text="üìπ Stop Live Recognition", bg="#e74c3c")
            self.camera_status_label.config(text="üìπ Live Camera: ACTIVE - Auto detecting faces", bg="#27ae60")
        elif not success and not self.live_camera_running:
            self.log_message("Failed to start live recognition.", "red")
            self.camera_status_label.config(text="üìπ Live Camera: INACTIVE - No registered faces", bg="#e67e22")

    def stop_live_camera(self):
        """Stops the background face recognition thread."""
        if not self.live_camera_running:
            return

        self.face_system.stop_live_recognition()
        self.live_camera_running = False
        self.live_camera_btn.config(text="üìπ Start Live Recognition", bg="#27ae60")
        self.camera_status_label.config(text="üìπ Live Camera: FEED ONLY", bg="#f39c12")
        self.log_message("Live recognition thread stopped.", "yellow")
        
    def toggle_live_camera(self):
        """The UI button handler to start or stop the recognition loop."""
        if self.live_camera_running:
            self.stop_live_camera()
        else:
            self.start_live_camera()


    # --- Registration Methods ---
    
    def auto_generate_id(self):
        """Generates the next sequential employee ID."""
        new_id = self.db_manager.generate_employee_id()
        self.emp_id_entry.delete(0, tk.END)
        self.emp_id_entry.insert(0, new_id)
        self.log_message(f"Generated new ID: {new_id}", "cyan")
        
    def registration_callback(self, success, message):
        """Callback from the face registration thread."""
        self.log_message(f"Registration status: {message}", "green" if success else "red")
        self.root.after(10, self.register_btn.config, {"state": tk.NORMAL, "text": "üì∏ Register Face"})
        
        if success:
            emp_id = self.emp_id_entry.get().strip()
            name = self.name_entry.get().strip()
            
            try:
                # 1. Log to DB
                self.db_manager.create_user(emp_id, name)
                # 2. Update UI
                self.root.after(10, self.refresh_user_list, emp_id)
                self.root.after(10, self.name_entry.delete, 0, tk.END)
                self.root.after(10, self.emp_id_entry.delete, 0, tk.END)
            except Exception as e:
                self.log_message(f"DB Error on user creation: {e}", "red")

    def register_user(self):
        """Starts the face registration process in a separate thread."""
        emp_id = self.emp_id_entry.get().strip()
        name = self.name_entry.get().strip()
        
        if not emp_id or not name:
            messagebox.showerror("Input Error", "Employee ID and Name cannot be empty.")
            return

        # Disable button to prevent multiple simultaneous captures
        self.register_btn.config(state=tk.DISABLED, text="Capturing...")
        self.log_message(f"Starting registration for {name} ({emp_id})...", "yellow")
        
        # Run registration in a thread to keep the GUI responsive
        threading.Thread(target=self.face_system.register_face, 
                         args=(emp_id, name, self.registration_callback), 
                         daemon=True).start()

    # --- Login/Logout Logic ---
    
    def handle_login(self, emp_id, method="face"):
        """Central logic to handle a successful login."""
        # 1. Check if already logged in
        if self.current_user == emp_id:
            self.log_message(f"User {emp_id} is already logged in.", "yellow")
            return
            
        user = self.db_manager.get_user(emp_id)
        if not user:
            self.log_message(f"ERROR: User ID {emp_id} not found in database.", "red")
            return

        # Check if the user is *globally* logged in based on DB records
        logged_in_users = self.db_manager.get_logged_in_users()
        if emp_id in logged_in_users:
            self.log_message(f"User {user['name']} is already logged in elsewhere.", "yellow")
            # We allow re-login/overwriting the logged-in state in the UI
        
        self.current_user = emp_id
        self.current_user_name = user['name']
        
        try:
            # 2. Log to DB
            self.db_manager.log_attendance(emp_id, user['name'], "LOGIN", method)
            # 3. Update UI
            self.update_status(f"Login Success: {user['name']}")
            self.log_message(f"LOGIN: {user['name']} ({emp_id}) via {method}", "green")
            self.refresh_user_list()
        except Exception as e:
            self.log_message(f"DB ERROR logging attendance: {e}", "red")

    def handle_logout(self, method="face"):
        """Central logic to handle a successful logout."""
        if not self.current_user:
            self.log_message("No user is currently logged into the application.", "yellow")
            return
        
        emp_id = self.current_user
        name = self.current_user_name
        
        try:
            # 1. Log to DB
            self.db_manager.log_attendance(emp_id, name, "LOGOUT", method)
            # 2. Reset local user state
            self.current_user = None
            self.current_user_name = None
            # 3. Update UI
            self.update_status(f"Logout Success: {name}")
            self.log_message(f"LOGOUT: {name} ({emp_id}) via {method}", "red")
            self.refresh_user_list()
        except Exception as e:
            self.log_message(f"DB ERROR logging attendance: {e}", "red")

    # --- Action Button Handlers ---
    
    def recognition_login_callback(self, emp_id, message):
        """Callback for the one-shot face recognition."""
        self.log_message(message, "blue")
        if emp_id:
            self.handle_login(emp_id, "face")
        self.root.after(10, self.update_status, message)
        
    def wave_login_handler(self, success, message):
        """Handler for the wave gesture detection result."""
        self.log_message(message, "blue")
        if success:
            # If wave detected, immediately start face recognition
            self.log_message("Gesture detected, attempting face login...", "cyan")
            threading.Thread(target=self.face_system.recognize_face, 
                             args=(self.recognition_login_callback,), 
                             daemon=True).start()
        self.root.after(10, self.update_status, message)

    def wave_login(self):
        """Starts the wave gesture detection process."""
        self.log_message("Starting wave gesture detection...", "cyan")
        # Run gesture detection in a thread
        threading.Thread(target=self.gesture_detector.detect_wave_gesture, 
                         args=(self.wave_login_handler,), 
                         daemon=True).start()
        self.update_status("Detecting wave gesture...")

    def fist_logout_handler(self, success, message):
        """Handler for the fist gesture detection result."""
        self.log_message(message, "blue")
        if success:
            self.handle_logout(method="gesture")
        self.root.after(10, self.update_status, message)

    def fist_logout(self):
        """Starts the fist gesture detection process."""
        if not self.current_user:
            messagebox.showinfo("Logout Status", "No user is currently logged in to log out.")
            return

        self.log_message("Starting fist gesture detection for logout...", "cyan")
        # Run gesture detection in a thread
        threading.Thread(target=self.gesture_detector.detect_fist_gesture, 
                         args=(self.fist_logout_handler,), 
                         daemon=True).start()
        self.update_status("Detecting fist gesture...")

    def manual_logout_selected(self):
        """Manually logs out the user selected in the Treeview."""
        try:
            selected_item = self.user_tree.selection()[0]
            user_data = self.user_tree.item(selected_item, 'values')
            emp_id, name = user_data[1], user_data[0]
            status = user_data[2]
            
            if status == "OUT":
                messagebox.showinfo("Logout Error", f"{name} ({emp_id}) is not currently logged in.")
                return

            if messagebox.askyesno("Confirm Manual Logout", 
                                   f"Manually log out user: {name} ({emp_id})?"):
                # If the selected user is the one logged into the app instance, perform the full logout
                if emp_id == self.current_user:
                    self.handle_logout(method="manual")
                else:
                    # Otherwise, just log the logout in the DB to update the global status
                    self.db_manager.log_attendance(emp_id, name, "LOGOUT", "manual")
                    self.log_message(f"LOGOUT: {name} ({emp_id}) via manual action", "red")
                    self.refresh_user_list()
                    self.update_status("Manual logout performed.")

        except IndexError:
            messagebox.showerror("Selection Error", "Please select a logged-in user from the list.")
        except Exception as e:
            self.log_message(f"ERROR during manual logout: {e}", "red")

    # --- Reporting Methods ---
    
    def view_attendance_window(self, records, title="Attendance Records"):
        """Displays attendance records in a new Tkinter window."""
        if not records:
            messagebox.showinfo("Records", "No attendance records found.")
            return

        records_window = tk.Toplevel(self.root)
        records_window.title(title)
        records_window.transient(self.root)
        records_window.grab_set()

        # Create a Treeview to display the records
        tree = ttk.Treeview(records_window, 
                            columns=("Timestamp", "Employee ID", "Name", "Action", "Method"), 
                            show="headings")
        tree.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Set headings
        tree.heading("Timestamp", text="Timestamp")
        tree.heading("Employee ID", text="ID")
        tree.heading("Name", text="Name")
        tree.heading("Action", text="Action")
        tree.heading("Method", text="Method")
        
        # Set column widths
        tree.column("Timestamp", width=180)
        tree.column("Employee ID", width=80)
        tree.column("Name", width=120)
        tree.column("Action", width=80)
        tree.column("Method", width=80)

        # Insert data
        for record in records:
            # Format the datetime object for display
            timestamp_str = record['timestamp'].strftime("%Y-%m-%d %H:%M:%S")
            tree.insert('', tk.END, values=(
                timestamp_str,
                record.get('emp_id', 'N/A'),
                record.get('name', 'N/A'),
                record.get('action', 'N/A'),
                record.get('method', 'N/A')
            ))
            
        records_window.wait_window(records_window) # Wait until the window is closed

    def view_my_attendance(self):
        """Shows attendance for the currently logged-in user."""
        if not self.current_user:
            messagebox.showinfo("Error", "Please log in to view your attendance.")
            return
            
        try:
            records = self.db_manager.get_attendance_records(self.current_user, limit=200)
            self.view_attendance_window(records, f"{self.current_user_name}'s Attendance Records")
        except Exception as e:
            messagebox.showerror("DB Error", f"Could not fetch my attendance records: {e}")

    def view_all_attendance(self):
        """Shows all attendance records (limited to 500 for performance)."""
        try:
            records = self.db_manager.get_attendance_records(limit=500)
            self.view_attendance_window(records, "All Attendance Records (Latest 500)")
        except Exception as e:
            messagebox.showerror("DB Error", f"Could not fetch all attendance records: {e}")

    def export_to_excel(self):
        """Exports all attendance records to a timestamped Excel file."""
        try:
            # Get all records without a limit
            all_records = list(self.db_manager.attendance_collection.find().sort("timestamp", -1))
            
            if not all_records:
                messagebox.showinfo("Export Status", "No records to export.")
                return

            # Convert MongoDB records to a Pandas DataFrame
            df = pd.DataFrame(all_records)
            
            # Clean up columns for export
            df = df.rename(columns={'_id': 'Record ID'})
            df = df[['Record ID', 'timestamp', 'emp_id', 'name', 'action', 'method']]
            df['timestamp'] = df['timestamp'].dt.strftime("%Y-%m-%d %H:%M:%S") # Format date
            
            # Prompt user for save location
            filename = filedialog.asksaveasfilename(
                defaultextension=".xlsx",
                initialfile=f"Attendance_Export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx",
                filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")]
            )
            
            if filename:
                df.to_excel(filename, index=False)
                messagebox.showinfo("Export Successful", f"Attendance records exported to:\n{filename}")
                self.log_message(f"Attendance records exported to {filename}", "green")
            else:
                self.log_message("Export cancelled.", "yellow")

        except Exception as e:
            messagebox.showerror("Export Error", f"An error occurred during export: {e}")
            self.log_message(f"ERROR during export: {e}", "red")

# -------------------- Run Application --------------------
if __name__ == '__main__':
    # Ensure the required directories exist before starting the app
    os.makedirs("data/faces", exist_ok=True) 
    
    root = tk.Tk()
    app = HandGestureLoginApp(root)
    
    try:
        root.mainloop()
    except KeyboardInterrupt:
        app.on_closing() # Ensure cleanup even on Ctrl+C in console